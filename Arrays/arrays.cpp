//Arrays
#include <iostream>
using namespace std;

void main()
{
	setlocale(LC_ALL, "");
	const int n = 5;
	int arr[n] = { 3,5,8 };
	arr[1] = 1024; //обращается к элементу массива на запись
	cout << arr[1] << endl; //обращаемся к элементу массива на чтение

	/*
	cout << "Введите элементы массива: "; //инициализация элементов массива с клавиатуры
	for (int i = 0; i < n; i++)
	{
		cin >> arr[i];
	}
	*/

	int minRand, maxRand;

	do
	{
		cout << "Введите минимальное случайное число: "; cin >> minRand;
		cout << "Введите максимальное случайное число: "; cin >> maxRand;
		if (minRand > maxRand) cout << "Минимальное должно быть меньше максимального" << endl;
		if (minRand == maxRand) cout << "Числа должны быть разные" << endl;
	} while (minRand >= maxRand);
	if (maxRand < minRand)
	{
		int buffer = minRand;
		minRand = maxRand;
		maxRand = buffer;
	}

	/*
	Для генерации случайного числа можно использовать функцию rand().
	Функция rand() возвращает псевдослучайное число в диапазоне от 0 до 32 767 (RAND_MAX)
	Это случайное число можно вывести на экран, сохранить в переменную или в элемент массива
	Для того, чтобы ограничить диапазон случайных чисел сверху, используется операция остаток от деления. Потому что остаток от деления всегда строго меньше делителя
	Для того, чтобы ограничить диапазон случайных чисел снизу, используется операция сложения
	*/
	for (int i = 0; i < n; i++)
	{
		arr[i] = rand() % (maxRand - minRand) + minRand;
	}

	// вывод в прямом порядке
	for (int i = 0; i < n; i++)
	{
		cout << arr[i] << "\t";
	}
	cout << endl;

	// вывод в обратном порядке
	for (int i = n - 1; i >= 0; i--)
	{
		cout << arr[i] << "\t";
	}
	cout << endl;

	// вычисление суммы среднего-арифметического:
	int sum = 0;
	for (int i = 0; i < n; i++)
	{
		sum += arr[i];
	
	}
	cout << "Сумма элементов массива: " << sum << endl;
	cout << "Среднее-арифметическое массива: " << (double)sum / n << endl;

	int min, max;
	min = max = arr[0];
	for (int i = 0; i < n; i++)
	{
		if (arr[i] < min)min = arr[i];
		if (arr[i] > max)max = arr[i];
	}
	cout << "Минимальное значение в массиве: " << min << endl;
	cout << "Максимальное значение в массиве: " << max << endl;

	for (int i = 0; i < n; i++) // Счетчик "i" выбирает элемент, в который нужно поместить минимальное значение
	{
		for (int j = i + 1; j < n; j++) //Счетчик "j" перебирает элементы, в поисках минимального значения
		{
			// arr [i] - выбранный элемент
			// arr [j] - перебираемый элемент
			if (arr[j] < arr[i])
			{
				int buffer = arr[i];
				arr[i] = arr[j];
				arr[j] = buffer;
			}
		}
	}
	for (int i = 0; i < n; i++)
	{
		cout << arr[i] << "\t";
	}
}
/*
Массивы

Массив (Array) - это набор переменных одного типа в непрерывной области памяти.

Массивы бывают:
1) Динамические
2) Статические

Количество элементов статического массива может быть задано лишь целочисленным константным значением на этапе написания кода.
Размер статического массива невозможно изменить после компиляции.

Размер динамического массива может быть задан переменным значением на этапе выполнения программы.
Предварительно это переменное значение можно вычислить или ввести с клавиатуры.

Одномерные, двумерные, трехмерные, …, многомерные:
Количество измерений массива ничем не ограничивается.

Массивы объявляются следующим образом:

type name [SIZE];

type - тип элементов массива.
Элементы одного массива могут одного определенного типа. В одном массиве не может быть один элемент bool, второй double, третий long и тд.
В массив можно определить элементы любого существующего типа.

name - имя массива. Для именования массива используются такие же идентификаторы, как и для наименования переменных.

SIZE - количество элементов массива. Может быть задано лишь целочисленным константным значением.

Обычно массивы объявляют так:
const int n = 5;
int arr[n];

Обращение к элементам массива:

Для того, чтобы обратиться к элементу массива, нужно указать его номер в квадратных скобках после имени массива.
К элементам массива, так же как и к обычным переменным, можно обращаться на чтении и запись.
Элементы массива нумеруются с нуля, поэтому последний элемент будет на 1 меньше.
То есть в массиве из пяти элементов отсутствует пятый элемент.

Элементы - value
Над элементами - индекс

Для обращения к элементам массива очень удобно использовать цикл for, поскольку у него есть счетчик i/, который можно задавать в качестве номера элемента.

Инициализация

При объявлении массива его элементы заполнены мусором. Для того, чтобы убрать из массива мусор, его нужно проинициализировать.
Для инициализации массива нужно перечислить значение его элементов в фигурных скобках через запятую. Элементы, значения которых не указаны при инициализации, получают значение по умолчанию. Для числовых типов это 0

Примечание:

Ошибка на этапе выполнения Run-Time Check Failure #2 возникает при выходе за пределы статического массива на запись. То есть, когда мы пытаемся записать значение не в сам массив, а рядом с ним

Сортировка массивов:

Существует множество алгоритмов сортировки, которые отличаются своей сложностью и эффективностью.
Самый простой и в то же время самый медленный алгоритм - это "пузырьковая" сортировка (buble sort). Также есть сортировка выбором, быстрая сортировка, сортировка Шелла и т.д.

Сортировка выбором:
При сортировке выбором в массиве условно выделяют два элемента:

1) Выбранный
2) Перебираемый

Если перебираемый элемент меньше, чем выбранный, то меняем их местами.
*/

/*
Двумерные массивы

Если одномерные массивы это просто набор значений в непрерывной области памяти, которые визуально обычно представляют строкой,
то двумерный массив - это таблица однотипных значений в непрерывной области памяти.

Как и в любой другой таблице, у двумерного массива есть строки и столбики. Столбики часто называют элементами строки.
Как строки, так и элементы строки, нумеруются с нуля.

При объявлении массива сразу указывают количество строк, затем количество элементов строки. Значение так же указывается константным значением.

Для обращение к элементам двумерного массива очень удобно использовать вложенные циклы. Как правило, основной цикл перебирает строки, а вложенный элементы строк (столбики)
*/